import { Request, Response } from "express";
import App, { IApp } from "../models/app.model";
import User, { IUser } from "../models/user.model";
import Chain from "../models/chain.model"; // Assuming chain.model.ts is created
import DefaultAppSettings from "../models/defaultAppSettings.model"; // Added import
import { successResponse, errorResponse } from "../utils/responseHandler"; // Assuming you have this
import { v4 as uuid } from "uuid"; // For API key generation if not handled by schema default

const MAX_APPS_PER_USER = 5;
// const DEFAULT_MAX_RPS = parseInt(process.env.DEFAULT_MAX_RPS || "20"); // This is now sourced from DefaultAppSettings

export class AppController {
  /**
   * Creates a new application for an authenticated user.
   * The application's initial rate limits (maxRps, dailyRequestsLimit) are sourced
   * from the global DefaultAppSettings.
   * @param req Express request object, expects { name, description?, chainName, chainId } in body.
   * @param res Express response object.
   */
  public async createApp(req: Request, res: Response): Promise<void> {
    try {
      const { name, description, chainName, chainId } = req.body;
      const userId = (req.user as IUser)?._id; // Assuming user is attached by auth middleware

      if (!userId) {
        errorResponse(res, 403, "User not authenticated.");
        return;
      }

      if (!name || !chainName || !chainId) {
        errorResponse(
          res,
          400,
          "Missing required fields: name, chainName, chainId."
        );
        return;
      }

      // Check app limit for the user
      const appCount = await App.countDocuments({ userId });
      if (appCount >= MAX_APPS_PER_USER) {
        errorResponse(
          res,
          403,
          `User cannot create more than ${MAX_APPS_PER_USER} apps.`
        );
        return;
      }

      // Verify chain existence and if it's enabled
      const chain = await Chain.findOne({
        name: chainName,
        chainId: chainId,
        isEnabled: true,
      });
      if (!chain) {
        errorResponse(
          res,
          404,
          `Chain '${chainName}' with chainId '${chainId}' not found or is not enabled.`
        );
        return;
      }

      // Fetch default app settings to apply to the new app.
      let appMaxRps: number;
      let appDailyRequestsLimit: number;

      const defaultSettings = await DefaultAppSettings.findOne();
      if (defaultSettings) {
        appMaxRps = defaultSettings.defaultMaxRps;
        appDailyRequestsLimit = defaultSettings.defaultDailyRequestsLimit;
      } else {
        // Fallback logic: If no DefaultAppSettings document exists in the database,
        // use hardcoded or environment-variable-based fallbacks.
        // This situation should be unlikely if the DefaultAppSettingsController.getDefaultAppSettings
        // endpoint has been called at least once, as it creates initial settings.
        console.warn(
          "DefaultAppSettings not found. Falling back to environment/hardcoded defaults for new app."
        );
        appMaxRps = parseInt(process.env.FALLBACK_DEFAULT_MAX_RPS || "20");
        appDailyRequestsLimit = parseInt(
          process.env.FALLBACK_DEFAULT_DAILY_LIMIT || "10000"
        );
      }

      const newApp = new App({
        name,
        description,
        userId,
        chainName: chain.name,
        chainId: chain.chainId,
        apiKey: uuid(), // apiKey is generated by schema default, but can be explicit here too
        maxRps: appMaxRps, // Use fetched or fallback default
        dailyRequestsLimit: appDailyRequestsLimit, // Use fetched or fallback default
        // dailyRequests and lastResetDate will use their schema defaults
      });

      await newApp.save();
      successResponse(res, 201, {
        message: "App created successfully.",
        app: newApp,
      });
    } catch (error) {
      console.error("Error creating app:", error);
      errorResponse(res, 500, {
        message: "Internal server error while creating app.",
        details: (error as Error).message,
      });
    }
  }

  /**
   * Retrieves all applications belonging to the authenticated user.
   * API keys are excluded from the response for security.
   * @param req Express request object, expects authenticated user via req.user.
   * @param res Express response object.
   */
  public async getUserApps(req: Request, res: Response): Promise<void> {
    try {
      const userId = (req.user as IUser)?._id;

      if (!userId) {
        errorResponse(res, 403, "User not authenticated.");
        return;
      }

      const apps = await App.find({ userId }).select("-apiKey"); // Exclude API key from general listing
      successResponse(res, 200, {
        message: "User applications retrieved successfully.",
        apps,
      });
    } catch (error) {
      console.error("Error retrieving user apps:", error);
      errorResponse(res, 500, {
        message: "Internal server error while retrieving apps.",
        details: (error as Error).message,
      });
    }
  }
}
